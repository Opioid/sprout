* Backlog

** Miscellaneous

*** DONE PCG Random Number Generator 
[[http://www.pcg-random.org/]]

** Integrators

*** TODO Subsurface scattering
- [X] Implement single scattering 
- [ ] Implement multiple scattering
  - [ ] Monte-carlo integrator
  - [ ] Next event estimation

** Materials

*** TODO Microfacets
**** TODO Correlated shadowing/masking function
[[https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf]]
[[http://twvideo01.ubm-us.net/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf]]

**** TODO Look into normalized Disney BRDF (see frostbite presentation)

**** TODO Thin-film
- [ ] Implement [[https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html]]
- [ ] Evaluate difference to existing thin-film fresnel

*** TODO Cloth material
- [ ] Investigate dedicated cloth material with alternative BRDF (e.g. Ashikhmin)

*** TODO Separate samplers
- [ ] Consider adding support for separate samplers per texture

** Renderer

*** TODO Lock-free tile enumeration
- [X] Pre-determined "Tiled scanline" with initial offset (slower)
- [ ] Atomics for access to next tile

It seems that the mutex communication is not the bottleneck in this scenario. 
Something with atomics might be interesting, but will probably not noticeably affect overall performance.

*** TODO Deterministic random numbers
Currently (some) random numbers are seeded per worker.
This leads to indeterministic behavior as the workers render varying parts of the frame per run. 

** Postprocessors

*** TODO Glare filter
- [-] Implement in Fourier domain to increase performance
  - [X] Use normal DFT to transform to Fourier domain and back
  - [ ] Investigate decreased quality, lattice like artifacts
  - [ ] Use FFT to improve performance

** Shapes

*** TODO Adding/improving analytical shapes
- [-] Canopy/Half-sphere
  - [X] Intersection
  - [ ] UV sampling
- [ ] Cylinder

*** TODO Consider visibility settings per part

** Resources

*** TODO Faster file loading
- [X] Consider concurrent loading during lengthy processing steps (e.g. building BVH)
- [-] Consider embedding json and binary data in single file
  - [X] Proof of concept
  - [ ] Support different vertex layouts
- [ ] Investigate performance of std::stream vs. fread() etc.

There is a very simple mechanism for asynchronous BVH construction now. 
It seems to work reasonably well in cases where BVH construction is followed by lengthy reads from disk.
In those cases the time required for BVH construction can be hidden to a certain degree.

Proof of concept for binary files showed good improvements in loading time. 
File size on disk generally seems to be higher, though.

** Build system

*** TODO Investigate more Travis CI usage

*** TODO Consider cmake-based build system

** Scene

*** TODO Faster scene update
- [-] Investigate opportunities to parallelize some parts of scene update
  - [-] Calculation of distribution LUTs for light sources
	- [X] Image
	- [ ] Mesh
  - [ ] Updating of entity transformations

The results are disappointing so far (e.g. less than 2x speedup for 12 threads).

*** DONE Streamline zero lights case
For example by automatically adding a null-light to scenes that otherwise don't have a light. 
This would remove some checks spread out over the codebase. 
